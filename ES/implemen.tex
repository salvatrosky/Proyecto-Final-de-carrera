%-*- ES -*-
%----------------------------------------------------------------------
% Capitulo: Implementacion de la solución propuesta
%----------------------------------------------------------------------

\section{Propuestas: Introducción}

Se han investigado tres alternativas enfocadas en redes internas para mejorar la seguridad de las 
mismas, luego de eso se eligió la que más ventajas nos ofreció.
Las alternativas son las siguientes: Los certificados auto-firmados (\emph{Self-signed Certificates}), implementar
una entidad certificante interna, y la utilización de un certificado emitido por una entidad
certificante conocida.

\section{Propuesta 1: Self-signed Certificates}
Los certificados autofirmados son los menos útiles de los tres. Firefox facilita su uso 
de forma segura; crea una excepción en la primera visita, después de lo cual el 
certificado autofirmado se considera válido en las conexiones posteriores. Otros 
navegadores hacen que haga clic en una advertencia de certificado cada vez. A menos 
que esté comprobando la huella digital del certificado cada vez, no es posible hacer 
que ese certificado autofirmado sea seguro. Incluso con Firefox, puede resultar 
difícil utilizar estos certificados de forma segura.

\begin{center}
   \begin{figure}   
      \begin{center}
         \includegraphics[width=13cm,height=9cm]{self-signed.png}
      \end{center}
      \caption{Advertencia Certificado Autofirmado}
   \end{figure}
\end{center}

Por ejemplo, para solicitar un certificado SSL de una CA de confianza como Verisign o 
GoDaddy, se debe enviar una Solicitud de firma de certificado (CSR) y te dan un 
certificado a cambio, que firmaron con su certificado raíz y clave privada. Todos 
los navegadores tienen una copia (o acceden a una copia desde el sistema operativo) 
del certificado raíz, por lo que el navegador puede verificar que su certificado 
fue firmado por una CA confiable.

Cuando generamos un certificado autofirmado, generamos nuestro propio certificado 
raíz y clave privada. Debido a que genera un certificado autofirmado, el navegador 
no confía en él. Está autofirmado. No ha sido firmado por una CA. Todos los 
certificados que generamos y firmamos serán de confianza inherente.

La principal dificultad es que los usuarios siempre encontrarán una advertencia 
donde el navegador diga que se encuentra en un sitio con un certificado autofirmado. 
En la mayoría de los casos, no verificarán que el certificado es el correcto, por 
lo que generará desconfianza en los usuarios.

En prácticamente todos los casos, un enfoque mucho mejor es utilizar una CA privada, 
que es nuestra próxima propuesta. Requiere un poco más de trabajo por adelantado, 
pero una vez que la infraestructura está establecida y la clave raíz se distribuye 
de manera segura a todos los usuarios, dichas implementaciones son tan seguras como 
el resto del ecosistema PKI.

\section{Propuesta 2: Internal CA}

Como se explicó anteriormente, una entidad de certificación es un agente en el que 
confiamos para emitir 
certificados que confirman las identidades de los suscriptores, o bien de los 
sitios a los cuales visitamos. 

Esta propuesta de solución implica establecer una entidad de certificación interna 
a la red privada, y por consiguiente hacer que los equipos que se encuentran 
dentro de la misma confíen el ella. Esto se hace 
mediante un servidor dedicado que firme los certificados que se le solicitan.

Ventajas de la autoridad de certificación interna (CA)
\begin{itemize}
   \setlength\itemsep{-0.6em}
   \item No es necesario depender de una entidad externa para los certificados.
   \item En un entorno de Microsoft Windows, la Autoridad de certificación (CA) interna se puede 
   integrar en Active Directory. Esto simplifica aún más la gestión de la estructura de la CA.
   \item No hay ningún costo por certificado cuando utiliza una Autoridad de certificación (CA) 
   interna.
\end{itemize}

Desventajas de la autoridad certificadora (CA) interna

\begin{itemize}
   \setlength\itemsep{-0.6em}
   \item Implementar una autoridad certificadora (CA) interna es más complicado que utilizar una 
   autoridad certificadora (CA) externa.
   \item La seguridad y la responsabilidad de la infraestructura de clave pública (PKI) está 
   completamente a cargo de la organización.
   \item Los usuarios externos que se conecten a nuestra red normalmente no confiarán en un 
   certificado digital 
   firmado por una Autoridad de Certificación (CA) interna.

\end{itemize}

Pese a que esta propuesta es de las más implementadas, decidimos buscar una opción que nos 
permita desligarnos de ciertas responsabilidades, como así también no tener que realizar 
configuraciones individuales a los hosts de nuestra organización. 

\subsection{Caso de estudio: Creando nuestra Entidad Certificante privada}
\input{dns}
\input{ca}

\section{Propuesta 3: Certificación con Let's Encrypt}
Esta estrategia consiste en generar un certificado wildcard, y utilizarlo en cada sitio de la organización.
Para esto se debe tener un dominio (en mi caso, salvadorcatalfamo.com) y demostrar la propiedad 
del mismo. Como se vio anteriormente, hay dos maneras que utiliza Let's Encrypt para demostrar la propiedad 
de un dominio, pero la que nos sirve en el caso de una red interna es la que intervienen los registros DNS. 
La verificación que ofrecen con este tipo de certificado es la mínima (DV) y el proceso es explicado a 
continuación.


\subsection{Pasos a seguir}
\subsubsection*{Obtener un dominio}
El primer paso es conseguir un dominio, en mi caso ya tenía uno:
salvadorcatalfamo.com. Este dominio apunta a nuestra ip pública. La configuración DNS
es la siguiente:  


\begin{longtable}{|l|l|p{5cm}|l|l|} 
   \hline
   \textbf{Tipo} & \textbf{Nombre} & \textbf{Contenido} & \textbf{Prioridad} & \textbf{TTL}
\\ \hline A  & salvadorcatalfamo.com & 181.228.121.12 & 0 & 14400
\\ \hline NS  & salvadorcatalfamo.com & ns1.donweb.com & 0 & 14400
\\ \hline SOA & salvadorcatalfamo.com & ns2.donweb.com & 0 & 14400
\\ \hline SOA & salvadorcatalfamo.com & ns3.hostmar.com \newline root.hostmar.com 
                                       \newline 2021010700 28800 7200 
                                       \newline 2000000 86400
                                       \newline ns2.donweb.com & 0 & 14400                  


\\ \hline
\end{longtable}

\subsubsection*{Instalando Let’s Encrypt en el servidor}
\begin{verbatim}
   sudo add-apt-repository ppa:certbot/certbotsudo 
   apt-get update
   sudo apt-get install python-certbot-nginx
\end{verbatim}

\subsubsection*{Instalando Nginx}
\begin{verbatim}
sudo apt-get update
sudo apt-get install nginx
\end{verbatim}


\subsubsection*{Obteniendo un certificado SSL de tipo wildcard desde Let’s Encrypt}
\begin{verbatim}
sudo certbot --server https://acme-v02.api.letsencrypt.org/directory 
-d *.salvadorcatalfamo.com --manual --preferred-challenges dns-01 certonly
\end{verbatim}

\subsubsection*{Configuración DNS}
Luego de ejecutar el comando anterior, Let's Encrypt nos da un contenido que 
se debe agregar a un registro DNS. El tipo de registro es TXT y se muestra en
la siguiente tabla.

\begin{longtable}{|l|l|l|l|l|} 
   \hline
   \textbf{Tipo} & \textbf{Nombre} & \textbf{Contenido} & \textbf{Prioridad} & \textbf{TTL}
\\ \hline TXT  & 	\_acme-challenge.salvadorcatalfamo.com & 11UZJD27bPDb\_jFs6f... & 0 & 14400
\\ \hline
\end{longtable}

\subsubsection*{Configuración de Nginx para servir a subdominios}

Se debe modificar el siguiente archivo de 
configuración 

/etc/nginx/sites-available/salvadorcatalfamo.com como se muestra a 
continuación:

\begin{verbatim}
server {
   listen 80;
   listen [::]:80;
   server_name *.salvadorcatalfamo.com;
   return 301 https://$host$request_uri;
}
server {
   listen 443 ssl;
   server_name *.example.com;  ssl_certificate /.../.../fullchain.pem;
   ssl_certificate_key /.../privkey.pem;
   include /etc/letsencrypt/options-ssl-nginx.conf;
   ssl_dhparam /.../ssl-dhparams.pem;  root /.../salvadorcatalfamo.com;
   index index.html;
   location / {
      try_files $uri $uri/ =404;
   }
} 
\end{verbatim}


\subsubsection*{Test la configuración y reinicio del servicio}

La configuración se puede testear con el siguiente comando: 
\begin{verbatim}
      sudo nginx -t
\end{verbatim}

Si tiene éxito, se debe volver a cargar Nginx usando
\begin{verbatim}
      sudo /etc/init.d/nginx reload
\end{verbatim}

Ahora Nginx contiene un certificado de tipo wildcard, un certificado SSL con respaldo de una 
entidad certificante como Let's Encrypt

\begin{center}
   \begin{figure}   
      \begin{center}
         \includegraphics[width=15cm,height=16cm]{lets.png}
      \end{center}
      \caption{Web interna con certificado de Let’s Encrypt}
   \end{figure}
\end{center}

Le hemos visto un gran potencial a esta solución, aunque también es poco implementada. Tenemos la gran ventaja de no
tener que instalar ningún requerimiento en las computadoras dentro de la organización. Con esto, no se 
mostrarán mensajes de seguridad en los navegadores, no importa cuál sea el programa, ya que Let's Encrypt es 
una entidad de confianza para diversos navegadores y sistemas operativos. Todo esto y la seguridad extra al 
saber que nuestros datos van por un canal seguro gracias al protocolo SSL. 

Otra gran ventaja que vimos es la facilidad con la que se llevó a cabo, 
en este proyecto se logró implementar antes esta solución que la entidad certificante, y 
con mucha mayor facilidad. 

Como desventajas podemos decir que no tenemos la posibilidad de obtener la validación extendida (EV), ya que no está
disponible actualmente. Por otro lado, que las llaves privadas y el certificado (que es único para todo el dominio) 
estén en diversos servidores a la vez, implica
que se deben tener mayores recaudos a la hora de utilizarlos, ya que se debe asegurar el control de éstos. Aunque a 
nosotros no nos sucedió, puede llegar a suceder que si se pierde conexión a Internet, el certificado no se pueda validar,
producto de no tener toda la cadena de certificación hasta llegar a la raíz. 

Aunque se puede llegar a pensar, administrar los certificados y las llaves puede llegar a ser 
un gran desafío para los administradores de sistema, sin embargo, hay muchas herramientas que nos proveen
automatización y monitoreo para realizar esta clase de tareas. 


\section{Caso de estudio: Buscando credenciales en tráfico seguro}

Luego de ver las diversas soluciones propuestas, una parte importante de 
nuestro proyecto fue verificar que verdaderamente aumenta la seguridad
cuando nuestro tráfico va encriptado. Para este caso de estudio, se utilizó
el mismo formulario propuesto en la sección \ref{secCaseOfStudy}, lo 
único que con servidores en distintas direcciones.

Dado que el proceso de capturar el tráfico en una red interna fue
explicado previamente, se van a mostrar únicamente los paquetes capturados
desde la primera solicitud hasta el envío del formulario.

\begin{center}
   \begin{figure}   
      \begin{center}
         \includegraphics[width=15cm,height=9cm]{verificacion-ssl-1-v2.png}
      \end{center}
      \caption{Tráfico capturado}
   \end{figure}
\end{center}

En esta captura podemos observar que:
\begin{itemize}
   \setlength\itemsep{-0.6em}
   \item No es posible determinar a simple vista cual es el paquete 
   en el cual se envía la información crítica.
   \item Abriendo e investigando el contenido de cada uno de los paquetes mostrados,
   tampoco es posible ver las credenciales completadas en el formulario, 
   que obviamente son de nuestro conocimiento.
   \item Se establece una conexión segura a través del protocolo TCP, algo que no 
   vimos en el caso de estudio de HTTP.
\end{itemize}


